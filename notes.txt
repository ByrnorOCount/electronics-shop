Backend (Express API with Node.js)
Frontend (React) (Vite)
Database (PostgreSQL)

Shared Config
Keep .env separate for backend vs frontend. (Look into whether this is necessary)
Example:
Backend .env → DB credentials, JWT secret, Stripe keys.
Frontend .env → API base URL, public Stripe key.

Commands
At the root folder (with workspaces):
# Install dependencies for all workspaces
npm run install-all

For backend:
cd backend
npm run dev       # start dev server with nodemon
npm run start     # production start
npm run migrate   # run latest migrations
npm run rollback  # rollback last migration
npm run seed      # run seeds

For frontend:
cd frontend
npm run dev     # Run Vite dev server
npm run build   # Build frontend for production
npm run preview # Preview production build

For root combined dev (both frontend + backend at once):
npm run dev

npm migrate creates the tables if they don't exist yet. If they do exist, it applies any new changes that haven't been applied yet.
npm seed populates the database with data. In our case, it clears the products table and adds sample products.

npx knex migrate:rollback: Destroys the tables created by the last migration.
npx knex migrate:latest: Re-creates the tables using your now-corrected migration file.
npx knex seed:run: Repopulates the fresh tables with your test data.

Using command line to view db (DBeaver is better as it's GUI)
psql -h localhost -p 5432 -U postgres -d electronics_shop
SELECT * FROM products;
exit: type \q and enter

postman/curl testing
apis for everything

focus on backend first to interact with api
then 3 weeks later match frontend with backend/database

diagrams
use case tables

làm thêm một bảng chức năng (các chức năng làm thì để bth còn để phát triển lên đồ án thì đánh màu)

tích hợp api:
	ship(giao hàng nhanh)
	payment (stripe)
tham khảo 

admin ->CRD(products,.., dashboard (thống kê theo products, order, theo lượng user user nào mua nhiều mua ít tăng hạng cho user (premium,..))
không đề cao phải tích hợp AI

log in using facebook, gg 

table phân công công việc (process, requirment (tiến độ công việc, 

kết nối front và back để xử lý xung đột nếu có

STORE PRODUCT IMAGES IN CLOUD (IN PRODUCTION)
Storage: AWS S3
Frontend (React): Vercel (prob this) / Netlify
Backend (Node.js): AWS Elastic Beanstalk (prob this) / Heroku / Render
Database (PostgreSQL): Amazon RDS / Heroku Postgres (prob this) / Render Postgres

cart:
thêm số lượng tồn kho vào, để trừ thêm sản phẩm vào số lượng 

+case mua sp a hết hàng ->sẽ có thông báo rằng nếu hết hàng sẽ đưa về trang products có gợi ý các sản phẩm tương tự còn sản phẩm,

+case mua sp a hết hàng b còn hàng-> thông báo khác: thông báo rằng sản phẩm a đã hết hàng rồi, nhưng b còn hàng bạn có muốn tiếp tục thanh toán không
-> trường hợp ko thanh toán thì trở về và đưa sp a vào whilists, cũng đưa về gợi ý sản phẩm tương tự nhưng sản phẩm b vẫn còn ở trong giỏ hàng

*tính năng bổ sung: api vnpay bị trục trặc (vì quá tải chẳng hạn token bị hạn chế,...) có thể sử dụng zalopay dùng qr code

snackbar/toast notifications for user actions (e.g., "Product added to cart", "Profile updated successfully", etc.)
profile page should have settings like default shipping address, payment methods, password change, etc.

zalo/github/twitter login

kill vnpay, use momo instead

# openapi.yaml validation
npm install -g @redocly/cli
redocly bundle backend/openapi/openapi.yaml -o backend/openapi/openapi.bundled.yaml
redocly lint backend/openapi/openapi.bundled.yaml
redocly lint backend/openapi/openapi.yaml

KILL tiny-csrf NO MORE I HATE tiny-csrf USE DOUBLE SUBMIT COOKIE CSRF

feature has slice file: service file returns response.data
feature doesn't: service file returns response.data.data
modules should follow _template module

Filtering options to the "Your Tickets" section on the support page (e.g., filter by status: open, closed)
The support tickets on the support page are static. Make them clickable to view a detailed page for each ticket

`import { xService } from "../../api";` must be used consistently no matter if the service file is in the exact same folder or not. That means no `import xService from "./xService";`



frontend/src/hooks/useApi vs frontend/src/store/hooks:

Server Cache State: This is data that actually lives on your backend server (e.g., products, orders, support tickets). Your frontend is just keeping a temporary, cached copy of it. This state has properties like loading, error, success, and can become "stale."

The useApi hook is perfect for this. It's designed specifically to manage the lifecycle of a single API request and its cached data directly within the component that needs it.
Global Client State: This is state that is truly global to the entire application and shared between many disconnected components.

Redux is still the best tool for this. The classic examples in our app are:
auth: The user's authentication status and profile info are needed everywhere (header, protected routes, etc.).
cart: The cart contents and total need to be accessible from the product page, the header, and the cart page itself.
Using Redux Thunks for every API call, as was done initially, mixes these concerns. It clutters the global Redux store with temporary server state that only one component might care about, leading to a lot of boilerplate (createAsyncThunk, extraReducers, etc.).